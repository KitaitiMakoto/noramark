%% name = NoraMark::Parser

# literals
eof = !. 
space = ' ' | '\t' 
eof_comment = space* "#" (!eof .)* 
comment =   space* "#" (!nl .)* nl empty_line*
- =  ( space | comment | eof_comment)*
empty_line = - nl
nl = /\r?\n/
le = nl | eof
word  = < /[\w0-9]/ ( '-' | /[\w0-9]/ )* >  { text }
num = < [0-9]+ > { text.to_i }


#common syntax
classname = '.' word:classname { classname }
classnames = (classname)*:classnames { classnames }
idname = '#' word:idname { idname }
idnames = (idname)*:idnames { idnames }

commandname = word:name idnames?:idnames classnames?:classes  { {name: name, ids: idnames, classes: classes} }
parameter_normal = < /[^,)]/* > { text }
parameter_quoted = '"' < /[^"]/* > '"' - &/[,)]/  { text }
parameter_single_quoted = "'" < /[^']/* > "'" - &/[,)]/ { text }
parameter = (parameter_quoted | parameter_single_quoted | parameter_normal ):value { value }
parameters = parameter:parameter (',' - parameter)*:rest_parameters { [parameter] + rest_parameters }
command = commandname:cn ('(' - parameters:args - ')')? { args ||= []; cn.merge({ args: args }) }

# paragraph
implicit_paragraph = < (!paragraph_delimiter - documentline:p -) > { create_item(:paragraph, nil, p, raw: text) }
paragraph = explicit_paragraph | implicit_paragraph 

# paragraph_group
paragraph_group = < paragraph+:p empty_line* > { create_item(:paragraph_group, nil, p, raw: text) }

# explicit block 
blockhead = - command:command - '{' - nl empty_line* { command }
blockend =  - '}' - le empty_line*
blockbody = (!blockend block)+:body { body } 
explicit_block = < blockhead:head - blockbody:body - blockend > { create_item(:block, head, body, raw: text) }

# preformatted block
preformatted_command = command:command &{ ['pre', 'code'].include? command[:name] }
preformatted_command_head_simple = - preformatted_command:command - '{' nl { command }
preformatted_command_head_complex = - preformatted_command:command - '{//' word?:codelanguage nl { command.merge({codelanguage: codelanguage}) }
preformatted_command_head = preformatted_command_head_complex | preformatted_command_head_simple
preformat_end_simple = '}' - le empty_line*
preformat_end_complex = '//}' - le empty_line*
preformatted_block_simple = < preformatted_command_head_simple:command (!preformat_end_simple (charstring nl))+:content preformat_end_simple > { create_item(:preformatted, command, content, raw: text) }
preformatted_block_complex = < preformatted_command_head_complex:command (!preformat_end_complex (charstring nl))+:content preformat_end_complex > { create_item(:preformatted, command, content, raw: text) }
preformatted_block = preformatted_block_complex | preformatted_block_simple

# inline command
inline = img_inline | common_inline
common_inline = < '[' command:c '{' documentcontent_except('}'):content '}' ']' > { create_item(:inline, c, content, raw: text) }
img_command = command:c &{ c[:name] == 'img' && c[:args].size == 2}
img_inline = < '[' img_command:c  ']' > { create_item(:inline, c, nil, raw: text) } 

# special line commands
commandname_for_special_line_command = newpage_command | explicit_paragraph_command

# newpage
newpage_command = command:command &{ command[:name] == 'newpage' }
newpage = < - newpage_command:c ':' documentcontent?:content - nl > { create_item(:newpage, c, content, raw:text) }

# explicit paragraph
explicit_paragraph_command = command:c &{ c[:name] == 'p' }
explicit_paragraph = < - explicit_paragraph_command:c ':' documentcontent?:content le empty_line*> { create_item(:paragraph, c, content, raw:text) }


# unordered list
unordered_list = < unordered_item+:items > { create_item(:ul, nil, items, raw: text) }
unordered_item = < '*:' documentcontent:content le > { create_item(:li, nil, content, raw: text) }

# ordered list
ordered_list = < ordered_item+:items > { create_item(:ol, nil, items, raw: text) }
ordered_item = < num ':' documentcontent:content le > { create_item(:li, nil, content, raw: text) }

# definition list
definition_list = < definition_item+:items > { create_item(:dl, nil, items, raw: text) }
definition_item = < - ';:' - documentcontent_except(':'):term ':' - documentcontent:definition le > { create_item(:dtdd, {args: [term, definition]}, nil, raw: text) }

# long definition list
long_definition_list = < long_definition_item+:items > { create_item(:dl, nil, items, raw: text) }
long_definition_item = < - ';:' - documentcontent_except('{'):term '{' - nl - blockbody:definition - blockend > { create_item(:dtdd, {args: [term, definition]}, nil, raw: text) }

items_list = unordered_list | ordered_list | definition_list | long_definition_list


# generic line command
line_command = < - !commandname_for_special_line_command command:c ':' documentcontent?:content - le empty_line* > { create_item(:line_command, c, content, raw: text) }

# blocks
line_block =  items_list | line_command 
block = (preformatted_block | headed_section | line_block  | explicit_block | paragraph_group ):block empty_line* {block}
block_delimiter = blockhead | blockend 
paragraph_delimiter = block_delimiter | preformatted_command_head | line_block | newpage | headed_start

# markdown-style headings
h_start_mark(n) = < '='+ ':' > &{ text.length - 1 == n }
h_markup_terminator(n) = - < '='+ ':' > &{ text.length - 1 <= n }

h_start(n) = - h_start_mark(n) charstring:s le { { level: n, heading: s } }
h_section(n) = < h_start(n):h (!h_markup_terminator(n) !eof block)+:content > { create_item(:h_section, h, content, raw: text) }

headed_start = h_start(1) | h_start(2) | h_start(3) | h_start(4) | h_start(5) | h_start(6)
headed_section = h_section(1) | h_section(2)| h_section(3)| h_section(4)| h_section(5) | h_section(6)

# frontmatter
frontmatter_separator =  - '---' - nl
frontmatter = frontmatter_separator (!frontmatter_separator ( charstring nl))+:yaml frontmatter_separator empty_line* { create_frontmatter(yaml) }

# texts
char = < /[[:print:]]/ > { text }
charstring = < char* > { text }
char_except(e) = char:c &{ c != e }
documentcontent_except(e) = (inline | !inline char_except(e))+:content ~parse_text(content)
documentcontent = (inline | !inline char)+:content  ~parse_text(content)
documentline = documentcontent:content le { content }

#page
page = frontmatter?:frontmatter - (!newpage block)*:blocks { create_item(:page, nil, ([frontmatter] +  blocks).select{ |x| !x.nil?}) }
newpaged_page = newpage:newpage page:page { page[:children] = page[:children].unshift newpage; page }

#root
root = page:page newpaged_page*:pages - eof_comment? eof { create_item(:document, {name: @document_name} , [ page ] + pages) }



