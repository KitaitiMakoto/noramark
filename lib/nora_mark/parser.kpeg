%% name = NoraMark::Parser

# literals
Eof = !. 
Space = ' ' | '\t' 
EofComment = Space* "#" (!Eof .)* 
Comment =   Space* "#" (!Nl .)* Nl EmptyLine*
- =  ( Space | Comment | EofComment)*
EmptyLine = - Nl
Nl = /\r?\n/
Le = Nl | Eof
Word  = < /[\w0-9]/ ( '-' | /[\w0-9]/ )* >  { text }
Num = < [0-9]+ > { text.to_i }


#common syntax
ClassName = '.' Word:classname { classname }
ClassNames = (ClassName)*:classnames { classnames }
IdName = '#' Word:idname { idname }
IdNames = (IdName)*:idnames { idnames }

CommandName = Word:name IdNames?:idnames ClassNames?:classes  { {name: name, ids: idnames, classes: classes} }
ParameterNormal = < /[^,)]/* > { text }
ParameterQuoted = '"' < /[^"]/* > '"' - &/[,)]/  { text }
ParameterSingleQuoted = "'" < /[^']/* > "'" - &/[,)]/ { text }
Parameter = (ParameterQuoted | ParameterSingleQuoted | ParameterNormal ):value { value }
Parameters = Parameter:parameter (',' - Parameter)*:rest_parameters { [parameter] + rest_parameters }
Command = CommandName:cn ('(' - Parameters:args - ')')? { args ||= []; cn.merge({ args: args }) }

# paragraph
ImplicitParagraph = < (!ParagraphDelimiter - DocumentLine:p -) > { create_item(:paragraph, nil, p, raw: text) }
Paragraph = ExplicitParagraph | ImplicitParagraph 

# paragraph_group
ParagraphGroup = < Paragraph+:p EmptyLine* > { create_item(:paragraph_group, nil, p, raw: text) }

# explicit block 
BlockHead = - Command:command - '{' - Nl EmptyLine* { command }
BlockEnd =  - '}' - Le EmptyLine*
BlockBody = (!BlockEnd Block)+:body { body } 
ExplicitBlock = < BlockHead:head - BlockBody:body - BlockEnd > { create_item(:block, head, body, raw: text) }

# preformatted block
PreformattedCommand = Command:command &{ ['pre', 'code'].include? command[:name] }
PreformattedCommandHeadSimple = - PreformattedCommand:command - '{' Nl { command }
PreformattedCommandHeadComplex = - PreformattedCommand:command - '{//' Word?:codelanguage Nl { command.merge({codelanguage: codelanguage}) }
PreformattedCommandHead = PreformattedCommandHeadComplex | PreformattedCommandHeadSimple
PreformatEndSimple = '}' - Le EmptyLine*
PreformatEndComplex = '//}' - Le EmptyLine*
PreformattedBlockSimple = < PreformattedCommandHeadSimple:command (!PreformatEndSimple (CharString Nl))+:content PreformatEndSimple > { create_item(:preformatted, command, content, raw: text) }
PreformattedBlockComplex = < PreformattedCommandHeadComplex:command (!PreformatEndComplex (CharString Nl))+:content PreformatEndComplex > { create_item(:preformatted, command, content, raw: text) }
PreformattedBlock = PreformattedBlockComplex | PreformattedBlockSimple

# inline command
Inline = ImgInline | CommonInline
CommonInline = < '[' Command:c '{' DocumentContentExcept('}'):content '}' ']' > { create_item(:inline, c, content, raw: text) }
ImgCommand = Command:c &{ c[:name] == 'img' && c[:args].size == 2}
ImgInline = < '[' ImgCommand:c  ']' > { create_item(:inline, c, nil, raw: text) } 

# special line commands
CommandNameForSpecialLineCommand = NewpageCommand | ExplicitParagraphCommand

# newpage
NewpageCommand = Command:command &{ command[:name] == 'newpage' }
Newpage = < - NewpageCommand:c ':' DocumentContent?:content - Nl > { create_item(:newpage, c, content, raw:text) }

# explicit paragraph
ExplicitParagraphCommand = Command:c &{ c[:name] == 'p' }
ExplicitParagraph = < - ExplicitParagraphCommand:c ':' DocumentContent?:content Le EmptyLine*> { create_item(:paragraph, c, content, raw:text) }


# unordered list
UnorderedList = < UnorderedItem+:items > { create_item(:ul, nil, items, raw: text) }
UnorderedItem = < '*:' DocumentContent:content Le > { create_item(:li, nil, content, raw: text) }

# ordered list
OrderedList = < OrderedItem+:items > { create_item(:ol, nil, items, raw: text) }
OrderedItem = < Num ':' DocumentContent:content Le > { create_item(:li, nil, content, raw: text) }

# definition list
DefinitionList = < DefinitionItem+:items > { create_item(:dl, nil, items, raw: text) }
DefinitionItem = < - ';:' - DocumentContentExcept(':'):term ':' - DocumentContent:definition Le > { create_item(:dtdd, {args: [term, definition]}, nil, raw: text) }

# long definition list
LongDefinitionList = < LongDefinitionItem+:items > { create_item(:dl, nil, items, raw: text) }
LongDefinitionItem = < - ';:' - DocumentContentExcept('{'):term '{' - Nl - BlockBody:definition - BlockEnd > { create_item(:dtdd, {args: [term, definition]}, nil, raw: text) }

ItemsList = UnorderedList | OrderedList | DefinitionList | LongDefinitionList


# generic line command
LineCommand = < - !CommandNameForSpecialLineCommand Command:c ':' DocumentContent?:content - Le EmptyLine* > { create_item(:line_command, c, content, raw: text) }

# blocks
LineBlock =  ItemsList | LineCommand 
Block = (PreformattedBlock | HeadedSection | LineBlock  | ExplicitBlock | ParagraphGroup ):block EmptyLine* {block}
BlockDelimiter = BlockHead | BlockEnd 
ParagraphDelimiter = BlockDelimiter | PreformattedCommandHead | LineBlock | Newpage | HeadedStart

# markdown-style headings
HStartMark(n) = < '='+ ':' > &{ text.length - 1 == n }
HMarkupTerminator(n) = - < '='+ ':' > &{ text.length - 1 <= n }

HStart(n) = - HStartMark(n) CharString:s Le { { level: n, heading: s } }
HSection(n) = < HStart(n):h (!HMarkupTerminator(n) !Eof Block)+:content > { create_item(:h_section, h, content, raw: text) }

HeadedStart = HStart(1) | HStart(2) | HStart(3) | HStart(4) | HStart(5) | HStart(6)
HeadedSection = HSection(1) | HSection(2)| HSection(3)| HSection(4)| HSection(5) | HSection(6)

# frontmatter
FrontmatterSeparator =  - '---' - Nl
Frontmatter = FrontmatterSeparator (!FrontmatterSeparator ( CharString Nl))+:yaml FrontmatterSeparator EmptyLine* { create_frontmatter(yaml) }

# texts
Char = < /[[:print:]]/ > { text }
CharString = < Char* > { text }
CharExcept(e) = Char:c &{ c != e }
DocumentContentExcept(e) = (Inline | !Inline CharExcept(e))+:content ~parse_text(content)
DocumentContent = (Inline | !Inline Char)+:content  ~parse_text(content)
DocumentLine = DocumentContent:content Le { content }

#page
Page = Frontmatter?:frontmatter - (!Newpage Block)*:blocks { create_item(:page, nil, ([frontmatter] +  blocks).select{ |x| !x.nil?}) }
NewpagedPage = Newpage:newpage Page:page { page[:children] = page[:children].unshift newpage; page }

#root
root = Page:page NewpagedPage*:pages - EofComment? Eof { create_item(:document, {name: @document_name} , [ page ] + pages) }



